## 삽입 정렬(insertion sort)

### 삽입 정렬 알고리즘 요약
- 손안의 카드를 정렬하는 방법과 유사
  - 새로운 카드를 기존의 정렬된 카드 사이에 옳바른 위치에 삽입
  - 새로 삽입할 카드의 수만큼 반복하면 정렬 완료
- 자료 배열의 모든 요소를 앞에서부터 차례로 이미 정렬된 배열 부분과 비교,  
  자신의 위치를 찾아 들어감

### 삽입 정렬 알고리즘의 구체적인 개념
- 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽) 자료들과 비교하여  
  삽입할 위치를 지정한 후, 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하는 알고리즘
- 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 첫 번째, 두 번째, 세 번째 자료와 비교한다
- 처음 key 값은 두 번쨰 자료부터 시작함

![img](C://Users//koni1//PycharmProjects//untitled//algorithm//img//삽입정렬.JPG)

### 삽입 정렬 구현 코드
~~~
def insertSort(arr):
    for i in range(2, len(arr)):
        tmp = arr[i]
        for j in range(i-1, -2, -1):
            if  arr[j] > tmp and j >= 0:
                arr[j+1] = arr[j]
            else:
                arr[j+1] = tmp
                break
    return arr
~~~

### 삽입 정렬 알고리즘 특징
- 장점
  - 안정한 정렬 방법
  - 레코드의 수가 적을수록 알고리즘 자체가 더 간단하므로 복잡한 정렬보다 더 유리할 수 있음
  - 대부분의 레코드가 정렬되어 있는 경우 효율적임
- 단점
  - 비교적 많은 레코드의 이동을 포함
  - 레코드의 수가 많을 때는 별로 유리하지 않음

### 삽입 정렬의 시간 복잡도 
- 최선의 경우
  - 비교 횟수
    - 이동 없이 한 번의 비교만 이루어짐 
    - 외부 루프 : n-1번

- 최악의 경우
  - 비교 횟수 : 1, 2, 3, 4, ..., n-3, n-2, n-1 : n(n-1)/2 = O(N^2)
  - 교환 횟수  
    - 외부 루프 단계마다 i+2번의 이동 발생 : O(N^2)
  - Worst T(n) : O(N^2)



